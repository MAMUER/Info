//Библиотеки
#include <iostream>  //библиотека ввода вывода
#include <fstream>   //библиотека работы с файлами
#include <string>    //библиотека работы со строками
#include <Windows.h> //библиотека SetConsoleCP

//Точка входа в программу
int main()           
{

}


using namespace std;    //включить автоматическую постановку std


setlocale(LC_ALL, "rus");     //вывод текста на русском


cout << y << endl;      //вывод

cin >> a;              //ввод


//типы данных 
int        //целочисленные
double     //дробные(до 15 знаков после запятой)
float      //дробные(до нескольких занков после запятой)
char       //только 1 символ
bool       //true или false (работает только с 0 и 1)


//                 //комментирование
/* */               //комментирование
return 0;              //конец программы
"\n"                  //перенос строки
=                    //присваивание
%                    //остаток от деления
==                   //сравнение
!=                   //не равно
&& или and           //логическое И
|| или or            //логическое ИЛИ
sqrt(a)              // корень
pow(a, b)            // возведение в степень
log(a)               //натуральный логарифм
abs(a)               //модуль числа
a++ <=> a + 1        //инкремент(постфиксный)
a-- <=> a - 1        //дикремент(постфиксный)
++a <=> a + a        //префиксный
--a <=> a - a        //префиксный
a = a + x <=> a += x //аналогично для вычитания, умножения и деления


1. Скобки
2. Возведение в степень
3. Умножение / деление
4. Инкремент / декремент(префиксный)
5. Сложение / вычитание / инкремент / декремент(постфиксный)

Цикл внутри другого цикла отрабатывает полностью, затем он выполняется полностью до окончания первого цикла.


Стандартное начало
#include <iostream> 
using namespace std;

int main()
{       
    setlocale(LC_ALL, "rus");



    return 0;
}


//условие 
if (условие)
{

}
else if (другое условие)
{

}
else
{

}


//цикл do while
do
{
    выражение
} 

while (true)
{    
        if (true)
        {
            break;
        }
}


    switch (выражение)
    {
    case 1:
    {
        Вы ввели 1
            break;
    }
    case 2:
    {
        Вы ввели 2
            break;
    }
    default:
    {
        Если ввели не 1 и не 2
            break;
    }


    while (правдивое условие выполнения цикла)
    {
        действие для повторения
    }


    const НАЗВАНИЕ_КОНСТАНТЫ      //её значение нельзя изменять в самой программе

//цикл for
for (x = первое число; x <= длина цикла; x = x + шаг)        
        {
            y = функция;

            if (условие)
            {
                break;  //прерывание цикла
                  или
                continue;  //цикл продолжит выполняться с пропуском одного шага
            }

            cout << " y = " << y << "\n";
        } 


    //goto
    cout << "1";

    goto  a;  //позволяет пропускать часть кода и переходить к локальному маркеру

    cout << "2";

    a:   //локальный маркер

    cout << "3";


//массив
тип_данных имя_массива[кол - во элементов];

имя_массива[номер элемента массива] = значение элемента массива;
            или
тип_данных имя_массива[] = {элементы массива через запятую};


sizeof(все, что угодно); //показывает размер в байтах
sizeof(имя_массива) / sizeof(тип данных) = sizeof(имя_массива) / sizeof(нулевой_элемент_массива) = > кол - во элементов массива


//рандомное число
srand(точка отсчёта случайных чисел);
rand() % число1 + число2; //генерирует случайные целые числа от 0 до 35000 (только один раз)
//диапазон равен от 1 до 3 включительно

//time
#include <ctime>
time(NULL) - отсчитывает кол - во секунд, прошедших с 1970 года


//двумерный массив
тип_данных имя_массива[строка][колонка]
{
{значения через запятую первой строчки},
{значения через запятую n - ой строчки}
};


//трёхмерный массив
тип_данных имя_массива[номер сетки][строка][колонка];


//функция
inline  int имя_функции(параметры)
{
    тело повторяющегося кода;
    return;
}


//шаблонная функция
template <typename или class T > //функция будет принимать любые типы данных


//факториал(дополнительная функция)
int fact(int n)
{
    if (n == 0)
    {
        return 0;
    }

    if (n == 1)
    {
        return 1;
    }
    return n * fact(n - 1);
}


//Работа с текстовым файлом
#include <Windows.h>
using namespace std;

class имя_класса
{
public:
    имя_класса()
    {
        имя_переменной = 0;
    }

    имя_класса(int имя_переменной)
    {
        this->имя_переменной = имя_переменной;
    }

    void Print()    //конструктор cout
    {
        cout << "имя_переменной = " << имя_переменной;
    }

    int имя_переменной;
};

#include <fstream>  
#include <string>

int main()
{
    setlocale(LC_ALL, "rus");

    имя_класса имя_переменной(1);    //запишем объект класса в текстовый файл
    имя_переменной.Print();

    ofstream fout;     //ofstream - запись данных в файл

    fout.open("название_текстового_файла.txt")       //открытие файла для записи
        или
        string path = "название_текстового_файла.txt";
    fout.open(path, ofstream::app); //открытие файл для записи(app-новые данные будут дописываться в конец файла)

    if (!fout.is_open())                         //Условие ввода данных в файл

    {
        cout << "Ошибка\n";
    }
    else
    {
        fout << "текст, записываемый в файл";
        или
            fout << цифры;
        или
            fout.write((char*)&имя_переменной, sizeof(имя_класса));    //write - сохранить объект класса в текстовый файл
    }

    fout.close();  //закрытие файла


    ifstream fin;     //ifstream - чтение данных из файла                    

    fin.open(path);           //открытие файл для чтения

    if (!fin.is_open())         //Условие вывода данных из файла
    {
        cout << "Ошибка\n" << endl;
    }

    else

    {
        string имя_строки;  //чтение данных построчно

        while (!fin.eof())    //eof - конец файла
        {
            имя_строки = "";   //затираем значение строки в начале итерации

            fin >> имя_строки;   //чтение строки из файла(до первого пробела)  
            cout << имя_строки;
                    или
            getline(fin, имя_строки);  //getline - считывает до конца строки (то откуда читаем, то куда читаем)
            cout << имя_строки;
                     или
            int const SIZE = 20;
            char имя_массива_чаров[SIZE];
            fin.getline(имя_массива_чаров, SIZE);
            cout << имя_массива_чаров;
        }
                  или
        char имя_элемента;       //чтение данных по одному элементу

        while (fin.get(имя_элемента))
        {
            cout << имя_элемента;
        }
                  или
        имя_класса имя_переменной_для_записи;     //чтение объекта класса из файла   
        while (fin.read((char*)&имя_переменной, sizeof(имя_класса)))  //будет считывать данные, пока они есть
        {
            имя_переменной_для_записи.Print();
        }
    }
    fin.close();      //закрытие файла

    fstream fs;      //fstream - читать/вводить
    fs.open(path, fstream::in | fstream::out | fstream::app);   //in - открыть для чтения  |-битовое "или"  out-открыть для записи

    if (!fin.is_open())         
    {
        cout << "Ошибка\n" << endl;
    }

    else
    {
        string буфер;

        cout << "1-записать в файл";
        cout << "2-считать из файла";
        cin >> имя_переменной;

        if (имя_переменной==1)   //запись в файл
        {
            SetConsoleCP(1251);  //переключение кодировки на русский язык
            cin >> буфер;
            fs << буфер;
            SetConsoleCP(866);  //переключение кодировки на английский язык
        }

        if (имя_переменной == 2)
        {
            while (!fs.eof())
            {
                буфер = "";

                fs >> буфер;
                cour << буфер;
            }
        }
    }
    fs.close();

    return 0;
}


//ДИНАМИЧЕСКАЯ ПАМЯТЬ
//New и delete
int* имя_указателя = new int; //новые данные за пределами программы
delete имя_указателя; //удаление данных из оперативной памяти


//NULL и nullptr
NULL == 0;

nullptr; //указатель на 0(отдельный тип данных)
имя_указателя = NULL == nullptr; //очистка ссылки указателя


//Динамический массив
int* имя_массива = new int[размер массива]; //новые данные за пределами программы
delete[] имя_массива;


//Двумерный динамический массив
int** имя_массива = new int* [кол - во_строк]; //новые данные за пределами программы

for (int i = 0; i < кол - во_строк; i++) //инициализация массива
{
    имя_массива[i] = new int[кол - во_колонок];
}

for (int i = 0; i < кол - во_строк; i++) //заполнение массива данными (вывод такой же)
{
    for (int j = 0; j < кол - во_колонок; j++)
    {
        имя_массива[i][j] = условие;
    }
}

for (int i = 0; i < кол - во_строк; i++) //удаление массива из памяти
{
    delete[] имя_массива[i];
}

delete[] имя_массива;

//Копирование массива (одинаковых размеров)
delete[] имя_первого_массива;

for (int i = 0; i < размер_массива; i++)
{
    имя_второго_массива[i] = имя_первого_массива[i];
}
delete[] имя_втоого_массива;


//Указатели
int* имя_указателя = имя_переменной;

имя_указателя = адрес переменной;

*имя_указателя = значение переменной;

//Ссылки
int& имя_ссылки = имя_переменной;

имя_ссылки = значение переменной;


//Строки
char имя_массива[] = "символы";
или
char имя_массива[] = { 'символ','символ','\0' };    //терминирующий ноль(\0) – конец строки
или
char* имя_массива = "символы";
или
char* имя_массива_строчек = { "строчка","строчка" };


strlen(имя_строки)    //длина строчки

имя_строки.resize();  //изменение размера строчки


strcat(имя_первого_массива, имя_второго_массива);  //объединение двух массивов в один (конкатенация)
или
strcat(имя_третьего_массива, имя_первого_массива);  //третий массив не должен быть заполнен мусором
strcat(имя_третьего_массива, имя_второго_массива);


#include <string>

string имя_первой_строчки = "символы";
string имя_второй_строчки = "символы";
string имя_третьей_строчки;

имя_третьей_строчки = имя_первой_строчки + имя_второй_строчки + "символы";  //объединение двух и более строк в одну (конкатенация)


//Преобразование типов
один_тип_данных имя_переменной;

cout << (другой_тип_данных)имя_переменной;

int имя_переменной = stoi(имя_string_переменной);

//Указатель на функцию
тип_функции(*имя_указателя)(тип_данных параметр);

имя_указателя = имя_функции;

имя_указателя();


//Директивы предпроцессора
#define имя_перменной(функции) значение_переменной(действие_функции) //переменная во всей программе будет заменена тем значением, которое здесь записано

//внутри функции
#ifdef или #ifndef(инвертированно) или #if(имя_переменной с условием) имя_переменной, определённой difine  //если есть, то код внутри работает, если её нет - то не работает
код;
#else или #elif(дополнительное условие)
другой_код;
#endif


//Тернарный оператор
условие ? действие : другое_действие; //то же самое, что и if else (?:)
или
условие ? действие : другое_условие ? : другое_действие;  //то же самое, что и if else {if else}


//Модификаторы доступа класса
private:        //тело класса доступно только самому классу
//при наследовании всегда private

public:         //тело класса доступно для использования программой
//при наследовании подстраивается под модифиактор наследования

protected:      //то же самое, что и private, но доступно для наследования (нельзя использовать в main)
//при наследовании всегда protected, кроме private (становится private)


//Класс
class имя_класса
    {
    private:                                     //модификатор доступа

        тип_параметра имя_параметра;             //поле класса

    public:

        имя_класса()    //конструктор класса по умолчанию (может быть несколько конструкторов с разными условиями)
        {
            имя_параметра = 0;
        };

        имя_класса(тип_параметра значение_имя_параметра)    //конструктор класса (передаёт введённые параметры в класс)
        {
            имя_параметра = значение_имя_параметра;    //здесь можно заранее инициализировать переменные
        };

        ~название_класса(деструктор не может принимать параметры) //деструктор (уничтожает объекты после выхода из функции)
        {
            delete[] название_динамического_массива;       //например
        };

        тип_параметра Getимя_параметра()             //вывести значение параметра
        {
            return имя_параметра;
        }

        void Setимя_параметра(тип_параметра значение_имя_параметра)    //установить значение параметра
        {
            имя_параметра = значение_имя_параметра;
        }
        или
        void Setимя_параметра(тип_параметра имя_параметра)
        {
            this->имя_параметра = имя_параметра //this хранит в памяти адрес объекта, в котором находится
        }

        тип_функции имя_функции()
        {
            тело_функции;

            return 0;
        }
    };

int main()
    {
        имя_класса имя_переменной(значение_параметра);    //значение параметра вводится заранее, если был создан конструктор класса

        имя_переменной.Setимя_параметра(значение_параметра);                      //ввод значения

        тип_параметра имя_другой_переменной = имя_переменной.Getимя_параметра();  //вывод значения

        имя_переменной.имя_функции();         //выполнение функции
    }
  
//конструкторы присваивания, сравнения, неравенства и деструктор
    using namespace std;
    class имя_класса
    {
    private:

        int* имя_параметра;

        int имя_другого_параметра;

    public:

        имя_класса(int size)      //конструктор динамического массива
        {
            this->SIZE = size;

            this->имя_параметра = new int[size];

            for (int i = 0; i < size; i++)
            {
                имя_параметра[i] = i;
            }

        };

        имя_класса(const имя_класса& имя_копии)   //конструктор копирования
        {
            this->SIZE = имя_копии.SIZE;

            this->имя_параметра = new int[имя_копии.SIZE];

            for (int i = 0; i < имя_копии.SIZE; i++)
            {
                this->имя_параметра[i] = имя_копии.имя_параметра[i];
            }
        }

        имя_класса& operator = (const имя_класса& имя_копии)   //перегрузка присваивания
        {
            this->SIZE = имя_копии.SIZE;

            if (this->имя_параметра != nullptr)
            {
                delete[] this->имя_параметра;
            }

            this->имя_параметра = new int[имя_копии.SIZE];

            for (int i = 0; i < имя_копии.SIZE; i++)
            {
                this->имя_параметра[i] = имя_копии.имя_параметра[i];
            }
            return *this;
        }

        bool operator ==(const имя_класса& другой_объект)  //перегрузка равенства
        {
            return this->имя_другого_параметра == другой_объект.имя_другого_параметра;
        }

        bool operator !=(const имя_класса& другой_объект)  //перегрузка неравенства
        {
            return !(this->имя_другого_параметра == другой_объект.имя_другого_параметра);
        }
                
        ~имя_класса() //деструктор
        {
            delete[] имя_параметра;
        };
    private:

        int SIZE;
    };

    int main()
    {
        имя_класса имя_переменной(2);

        имя_класса имя_другой_переменной(имя_переменной);    //копирование переменной

        имя_класса имя_третьей_переменной(4);

        bool result = (имя_переменной == имя_третьей_переменной);   //равенство или неравенство

        имя_переменной = имя_третьей_переменной;     //присваивание значения переменной    

        return 0;
    }

//перегрузка операторов   
    #include <iostream>
    using namespace std;
    class имя_класса
    {
    private:

        double имя_переменной = 0;
        double имя_другой_переменной = 0;

    public:

        имя_класса operator +(const имя_класса& n2) //перегрузка сложения
        {
            имя_класса buff;

            buff.имя_переменной = this->имя_переменной + n2.имя_переменной;
            buff.имя_другой_переменной = this->имя_другой_переменной + n2.имя_другой_переменной;

            return buff;
        }
         
        имя_класса operator -(const имя_класса& n2) //перегрузка вычитания
        {
            имя_класса buff;

            buff.имя_переменной = this->имя_переменной - n2.имя_переменной;
            buff.имя_другой_переменной = this->имя_другой_переменной - n2.имя_другой_переменной;

            return buff;
        }

        имя_класса operator *(const имя_класса& n2) //перегрузка умножения
        {
            имя_класса buff;

            buff.имя_переменной = this->имя_переменной * n2.имя_переменной;
            buff.имя_другой_переменной = this->имя_другой_переменной * n2.имя_другой_переменной;

            return buff;
        }

        имя_класса operator /(const имя_класса& n2) //перегрузка деления
        {
            имя_класса buff;

            buff.имя_переменной = this->имя_переменной / n2.имя_переменной;
            buff.имя_другой_переменной = this->имя_другой_переменной / n2.имя_другой_переменной;

            return buff;
        }

        void operator =(const имя_класса& n2) //перегрузка присваивания
        {
            this->имя_переменной = n2.имя_переменной;
            this->имя_другой_переменной = n2.имя_другой_переменной;
        }

        имя_класса operator ++() //перегрузка префиксного инкремента
        {
            this->имя_переменной++;
            this->имя_другой_переменной++;

            return *this;
        }

        имя_класса operator ++(int a) //перегрузка постфиксного инкремента
        {
            имя_класса buff;

            buff = *this;

            this->имя_переменной++;
            this->имя_другой_переменной++;

            return buff;
        }

        имя_класса operator --() //перегрузка префиксного дикремента
        {
            this->имя_переменной--;
            this->имя_другой_переменной--;

            return *this;
        }

        имя_класса operator --(int a) //перегрузка постфиксного дикремента
        {
            имя_класса buff;

            buff = *this;

            this->имя_переменной--;
            this->имя_другой_переменной--;

            return buff;
        }

        имя_класса & operator [](const int ind) //перегрузка индексирования
        {
            return имя_массива[ind];
        }

        friend имя_другого_класса; //дружественный класс (имеет доступ ко всем методам этого класса)

        friend тип_функции имя_другого_класса::имя_функции_в_другом_классе(параметры функции); //дружественный метод класса (нужно определить другой_класс выше), вынести определение метода за класс

        friend ostream& operator <<(ostream& buff, const имя_класса& n1) //перегрузка cout (через дружественную функцию)
        {
            buff << "\n" << n1.имя_переменной << " / " << n1.имя_другой_переменной << "\n";
            return buff;
        }

        friend istream& operator >>(istream& in, имя_класса& n1) //перегрузка cin (через дружественную функцию)
        {
            in >> n1.имя_переменной;
            in >> n1.имя_другой_переменной;
            return in;
        }
    };

//friend функция при объявлении внутри класса имеет доступ к любому разделу класса (также может быть глобальной)

//static (объект класса)
    static тип_static_переменной имя_static_переменной; //внутри класса (её значение одинаково для всех обЪектов класса)

    тип_static_переменной имя_класса::имя_static_переменной = число; //инициализация вне класса

    имя_static_переменной++; //изменение значения static переменной внутри класса (например)

//обращение к static переменной
    static тип_static_переменной Get_имя_static_переменной //внутри класса (public), получить значение static переменной
    {
        return имя_static_переменной;
    }

    имя_класса::Get_имя_static_переменной; //в main функции

//внутренние классы (можно создать класс внутри другого класса)
    
//массив элементов класса (для создания необходимо создать конструктор по умолчанию)

//наследование
    class имя_класса
    {
    public:
        имя_класса() {}
    };

    class имя_другого_класса : public имя_класса //наследование
    {
        имя_другого_класса():имя_класса(){} //вызов базового конструктора
    };

    class имя_третьего_класса : public имя_другого_класса //множественное наследование
    {};

//virtual позволяет ту же функцию переопределить в классе - наследнике

//override позволяет проверить наличие переопределения функции

//абстрактный - класс, объект которого нельзя создать, с чисто виртуальным конструктором или деструктором
    имя_класса() {} = 0;    или    ~имя_класса() {} = 0;
    //чисто виртуальный деструктор определяется вне класса

//вызов виртуального метода базового класса
    тип_метода_класса метод_класса() override
    {
        ::имя_базового_класса::метод_класса();
    }

//множественное наследование
    class класс 
    {public:
        void метод() {}
    };

    class другой_класс 
    {
    public:
        void метод() {}
    };

    class третий_класс :класс, другой_класс {};

    int main()
    {
        третий_класс a;
        ((класс)a).метод(); //перегрузка метода для первого класса
    }

//интерфейсы - такие абстрактные классы, все методы которого чисто виртуальные

//ромбовидное (виртуальное) наследование (исключение копирования изначального класса)
    class класс{};

    class другой_класс :public virtual класс {};

    class третий_класс :public virtual класс {};

    class четвертый_класс :третий_класс, другой_класс {};

//Пространства имён        
    namespace имя_пространства //функции с одинаковыми именами не будут мешать друг другу
    {
        имя_функции()
        {
        }
    }

    namespace имя_другого_пространства
    {
        имя_функции()
        {
        }
    }

    namespace имя_третьего_пространства
    {
        namespace имя_пространства
        {
            имя_функции()
            {
            }
        }
    }

    int main ()
    {
        имя_пространства::имя_функции;
        имя_третьего_пространства::имя_пространства::имя_функции;
    }


//Графика
#include <windows.h> //чтобы работать с графикой
#include < conio.h > //чтобы _getch работал

int main()
{
    HWND myconsole = GetConsoleWindow(); //HWND - класс окна консоли   myconsole - имя переменной   GetConsoleWindow() - извлекает маркер окна, используемый консолью, связанной с вызывающим процессом

    HDC mydc = GetDC(myconsole); //HDC - обработчик контекста устройства, использующийся для рисования в клиентской области окна  mydc - имя переменной  GetDC() - возвращает контекст устройства окна
    
    int pixel = 0;

    COLORREF COLOR = RGB(255, 255, 255); //выбрать цвет

    //нарисовать пиксели    
    for (double i = 0; i < PI * 4; i += 0.05)
    {
        SetPixel(mydc, x, y, COLOR);
        pixel += 1;
    }

    _getch(); //возвращает значение переменной (изображение после напечатывания не закроется)

    ReleaseDC(myconsole, mydc); //ReleaseDC() - освобождает ресурсы, которые были заняты при использовании GetDC

    return 0;
}   


//Библиотека стандартных шаблонов (stl)
//Vector по сути - класс динамического массива
#include <vector>
using namespace std;

vector<тип_данных> имя_вектора = { элемент,2 элемент, 3 элемент и т.д. };

vector<тип_данных> имя_вектора(кол-во элементов, значение по умолчанию); //указываем кол-во элементов в векторе заранее

имя_вектора.push_back(сюда);  //добавление элемента в конец 

имя_вектора[номер_элемента]; //обращение к элементу

имя_вектора.size(); //кол-во значащих элементов

имя_вектора.at(сюда); //аналогично квадратным скобкам, но проверяет, можем ли мы обратиться к элементу. Соответственно медленнее, чем []

имя_вектора.clear(); //очистка вектора

имя_вектора.pop_back(); //удаление последнего элемента

имя_вектора.capacity(); //кол-во ячеек, зарезервированных вектором

имя_вектора.receive(сюда); //указание кол-ва ячеек, заранее зарезервированных вектором

имя_вектора.shrink_to_fit(); //освобождение пустых ячеек

имя_вектора.empty(); //true - в векторе нет элементов, false - наоборот

имя_вектора.resize(кол - во элементов, значение по умолчанию); //изменение кол-ва элементов в векторе

имя_вектора.insert(); //вставка элемента в любую ячейку

имя_вектора.erase(); //удаление элемента из любой ячейки